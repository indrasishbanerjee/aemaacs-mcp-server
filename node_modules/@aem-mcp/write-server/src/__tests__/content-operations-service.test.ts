/**
 * Unit tests for Content Operations Service
 */

import { ContentOperationsService, CreateFolderOptions, CopyFolderOptions, UploadFileOptions, UpdatePropertiesOptions, DeleteContentOptions, ReindexOptions } from '../services/content-operations-service.js';
import { AEMHttpClient } from '../../../shared/src/client/aem-http-client.js';
import { AEMException } from '../../../shared/src/utils/errors.js';

// Mock the AEM HTTP Client
jest.mock('../../../shared/src/client/aem-http-client.js');
jest.mock('../../../shared/src/utils/logger.js');

describe('ContentOperationsService', () => {
  let contentService: ContentOperationsService;
  let mockClient: jest.Mocked<AEMHttpClient>;

  beforeEach(() => {
    mockClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn(),
      delete: jest.fn(),
      upload: jest.fn(),
      getStats: jest.fn(),
      clearCache: jest.fn(),
      resetCircuitBreaker: jest.fn(),
      close: jest.fn()
    } as unknown as jest.Mocked<AEMHttpClient>;

    contentService = new ContentOperationsService(mockClient);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createFolder', () => {
    const mockCreateFolderResponse = {
      success: true,
      data: {
        success: true,
        path: '/content/test/newfolder',
        message: 'Folder created successfully'
      },
      metadata: {
        timestamp: new Date(),
        requestId: 'test-request-id',
        duration: 150
      }
    };

    it('should create folder successfully', async () => {
      const parentPath = '/content/test';
      const folderName = 'newfolder';
      const options: CreateFolderOptions = {
        title: 'New Folder',
        description: 'Test folder description',
        properties: {
          'custom:property': 'value'
        }
      };

      mockClient.post.mockResolvedValue(mockCreateFolderResponse);

      const result = await contentService.createFolder(parentPath, folderName, options);

      expect(result.success).toBe(true);
      expect(result.data!.success).toBe(true);
      expect(result.data!.path).toBe('/content/test/newfolder');
      expect(result.data!.folderType).toBe('sling:Folder');

      expect(mockClient.post).toHaveBeenCalledWith(
        '/content/test/newfolder',
        expect.any(Object), // FormData
        expect.objectContaining({
          context: {
            operation: 'createFolder',
            resource: '/content/test/newfolder'
          }
        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('jcr:primaryType')).toBe('sling:Folder');\n      expect(formData.get('jcr:title')).toBe('New Folder');\n      expect(formData.get('jcr:description')).toBe('Test folder description');\n      expect(formData.get('custom:property')).toBe('value');\n    });\n\n    it('should create ordered folder successfully', async () => {\n      const parentPath = '/content/test';\n      const folderName = 'orderedfolder';\n\n      mockClient.post.mockResolvedValue({\n        ...mockCreateFolderResponse,\n        data: {\n          ...mockCreateFolderResponse.data,\n          path: '/content/test/orderedfolder'\n        }\n      });\n\n      const result = await contentService.createOrderedFolder(parentPath, folderName);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.folderType).toBe('sling:OrderedFolder');\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('jcr:primaryType')).toBe('sling:OrderedFolder');\n    });\n\n    it('should throw validation error for missing parameters', async () => {\n      await expect(contentService.createFolder('', 'folder')).rejects.toThrow(AEMException);\n      await expect(contentService.createFolder('/content', '')).rejects.toThrow(AEMException);\n      await expect(contentService.createFolder('', '')).rejects.toThrow('Parent path and folder name are required');\n    });\n\n    it('should throw validation error for invalid folder name', async () => {\n      const invalidNames = ['folder/name', 'folder[name]', 'folder:name', 'folder|name', 'folder*name'];\n      \n      for (const invalidName of invalidNames) {\n        await expect(contentService.createFolder('/content', invalidName)).rejects.toThrow(AEMException);\n        await expect(contentService.createFolder('/content', invalidName)).rejects.toThrow('Invalid folder name');\n      }\n    });\n\n    it('should handle server errors gracefully', async () => {\n      const errorResponse = {\n        success: false,\n        error: { \n          code: 'SERVER_ERROR', \n          message: 'Internal server error',\n          recoverable: true\n        }\n      };\n      mockClient.post.mockResolvedValue(errorResponse);\n\n      await expect(contentService.createFolder('/content', 'folder')).rejects.toThrow(AEMException);\n      await expect(contentService.createFolder('/content', 'folder')).rejects.toThrow('Failed to create folder');\n    });\n  });\n\n  describe('copyFolder', () => {\n    const mockCopyResponse = {\n      success: true,\n      data: {\n        success: true,\n        message: 'Folder copied successfully'\n      },\n      metadata: {\n        timestamp: new Date(),\n        requestId: 'test-request-id',\n        duration: 200\n      }\n    };\n\n    it('should copy folder successfully', async () => {\n      const sourcePath = '/content/source';\n      const destinationPath = '/content/destination';\n      const options: CopyFolderOptions = {\n        recursive: true,\n        overwrite: false,\n        preserveProperties: true\n      };\n\n      mockClient.post.mockResolvedValue(mockCopyResponse);\n\n      const result = await contentService.copyFolder(sourcePath, destinationPath, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.success).toBe(true);\n      expect(result.data!.path).toBe(destinationPath);\n\n      expect(mockClient.post).toHaveBeenCalledWith(\n        sourcePath,\n        expect.any(Object), // FormData\n        expect.objectContaining({\n          context: {\n            operation: 'copyFolder',\n            resource: sourcePath\n          }\n        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get(':operation')).toBe('copy');\n      expect(formData.get(':dest')).toBe(destinationPath);\n      expect(formData.get(':deep')).toBe('true');\n      expect(formData.get(':replace')).toBe('false');\n    });\n\n    it('should throw validation error for missing paths', async () => {\n      await expect(contentService.copyFolder('', '/dest')).rejects.toThrow(AEMException);\n      await expect(contentService.copyFolder('/source', '')).rejects.toThrow(AEMException);\n      await expect(contentService.copyFolder('', '')).rejects.toThrow('Source path and destination path are required');\n    });\n  });\n\n  describe('uploadFile', () => {\n    const mockUploadResponse = {\n      success: true,\n      data: {\n        success: true,\n        path: '/content/test/file.txt',\n        message: 'File uploaded successfully'\n      },\n      metadata: {\n        timestamp: new Date(),\n        requestId: 'test-request-id',\n        duration: 300\n      }\n    };\n\n    it('should upload file successfully', async () => {\n      const parentPath = '/content/test';\n      const fileName = 'test.txt';\n      const fileContent = Buffer.from('Hello, World!');\n      const options: UploadFileOptions = {\n        mimeType: 'text/plain',\n        overwrite: true,\n        properties: {\n          'dc:title': 'Test File'\n        }\n      };\n\n      mockClient.post.mockResolvedValue(mockUploadResponse);\n\n      const result = await contentService.uploadFile(parentPath, fileName, fileContent, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.success).toBe(true);\n      expect(result.data!.path).toBe('/content/test/test.txt');\n      expect(result.data!.fileName).toBe('test.txt');\n      expect(result.data!.mimeType).toBe('text/plain');\n      expect(result.data!.size).toBe(13);\n\n      expect(mockClient.post).toHaveBeenCalledWith(\n        '/content/test/test.txt',\n        expect.any(Object), // FormData\n        expect.objectContaining({\n          context: {\n            operation: 'uploadFile',\n            resource: '/content/test/test.txt'\n          }\n        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('jcr:primaryType')).toBe('nt:file');\n      expect(formData.get('jcr:content/jcr:primaryType')).toBe('nt:resource');\n      expect(formData.get('jcr:content/jcr:mimeType')).toBe('text/plain');\n      expect(formData.get(':replace')).toBe('true');\n      expect(formData.get('jcr:content/dc:title')).toBe('Test File');\n    });\n\n    it('should detect MIME type automatically', async () => {\n      const parentPath = '/content/test';\n      const fileName = 'image.jpg';\n      const fileContent = Buffer.from('fake image data');\n\n      mockClient.post.mockResolvedValue(mockUploadResponse);\n\n      const result = await contentService.uploadFile(parentPath, fileName, fileContent);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.mimeType).toBe('image/jpeg');\n      \n      // Verify MIME type was set correctly\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('jcr:content/jcr:mimeType')).toBe('image/jpeg');\n    });\n\n    it('should throw validation error for missing parameters', async () => {\n      const fileContent = Buffer.from('test');\n      \n      await expect(contentService.uploadFile('', 'file.txt', fileContent)).rejects.toThrow(AEMException);\n      await expect(contentService.uploadFile('/content', '', fileContent)).rejects.toThrow(AEMException);\n      await expect(contentService.uploadFile('/content', 'file.txt', null as any)).rejects.toThrow(AEMException);\n    });\n\n    it('should throw validation error for invalid file name', async () => {\n      const fileContent = Buffer.from('test');\n      const invalidNames = ['file/name.txt', 'file[name].txt', 'file:name.txt'];\n      \n      for (const invalidName of invalidNames) {\n        await expect(contentService.uploadFile('/content', invalidName, fileContent)).rejects.toThrow(AEMException);\n        await expect(contentService.uploadFile('/content', invalidName, fileContent)).rejects.toThrow('Invalid file name');\n      }\n    });\n  });\n\n  describe('updateProperties', () => {\n    const mockUpdateResponse = {\n      success: true,\n      data: {\n        success: true,\n        message: 'Properties updated successfully'\n      },\n      metadata: {\n        timestamp: new Date(),\n        requestId: 'test-request-id',\n        duration: 100\n      }\n    };\n\n    it('should update properties successfully', async () => {\n      const nodePath = '/content/test/node';\n      const properties = {\n        'jcr:title': 'Updated Title',\n        'jcr:description': 'Updated Description',\n        'custom:property': 'custom value',\n        'multi:value': ['value1', 'value2'],\n        'boolean:prop': true,\n        'number:prop': 42\n      };\n\n      mockClient.post.mockResolvedValue(mockUpdateResponse);\n\n      const result = await contentService.updateProperties(nodePath, properties);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.success).toBe(true);\n      expect(result.data!.path).toBe(nodePath);\n      expect(result.data!.updatedProperties).toEqual([\n        'jcr:title', 'jcr:description', 'custom:property', 'multi:value', 'boolean:prop', 'number:prop'\n      ]);\n\n      expect(mockClient.post).toHaveBeenCalledWith(\n        nodePath,\n        expect.any(Object), // FormData\n        expect.objectContaining({\n          context: {\n            operation: 'updateProperties',\n            resource: nodePath\n          }\n        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('jcr:title')).toBe('Updated Title');\n      expect(formData.get('jcr:description')).toBe('Updated Description');\n      expect(formData.get('custom:property')).toBe('custom value');\n      expect(formData.get('multi:value[0]')).toBe('value1');\n      expect(formData.get('multi:value[1]')).toBe('value2');\n      expect(formData.get('boolean:prop')).toBe('true');\n      expect(formData.get('number:prop')).toBe('42');\n    });\n\n    it('should handle property removal when removeExisting is true', async () => {\n      const nodePath = '/content/test/node';\n      const properties = {\n        'jcr:title': 'New Title'\n      };\n      const options: UpdatePropertiesOptions = {\n        removeExisting: true\n      };\n\n      // Mock existing properties response\n      mockClient.get.mockResolvedValue({\n        success: true,\n        data: {\n          'jcr:title': 'Old Title',\n          'old:property': 'old value',\n          'jcr:primaryType': 'nt:unstructured' // Should not be removed\n        }\n      });\n      mockClient.post.mockResolvedValue(mockUpdateResponse);\n\n      const result = await contentService.updateProperties(nodePath, properties, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.removedProperties).toContain('old:property');\n      expect(result.data!.removedProperties).not.toContain('jcr:primaryType');\n      \n      // Verify removal was requested\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('old:property@Delete')).toBe('');\n    });\n\n    it('should throw validation error for missing parameters', async () => {\n      await expect(contentService.updateProperties('', {})).rejects.toThrow(AEMException);\n      await expect(contentService.updateProperties('/content/node', null as any)).rejects.toThrow(AEMException);\n      await expect(contentService.updateProperties('', {})).rejects.toThrow('Node path and properties are required');\n    });\n  });\n\n  describe('deleteContent', () => {\n    const mockDeleteResponse = {\n      success: true,\n      data: {\n        success: true,\n        message: 'Content deleted successfully'\n      },\n      metadata: {\n        timestamp: new Date(),\n        requestId: 'test-request-id',\n        duration: 150\n      }\n    };\n\n    it('should delete content successfully', async () => {\n      const contentPath = '/content/test/deleteme';\n      const options: DeleteContentOptions = {\n        force: true,\n        recursive: true\n      };\n\n      mockClient.post.mockResolvedValue(mockDeleteResponse);\n\n      const result = await contentService.deleteContent(contentPath, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.success).toBe(true);\n      expect(result.data!.path).toBe(contentPath);\n\n      expect(mockClient.post).toHaveBeenCalledWith(\n        contentPath,\n        expect.any(Object), // FormData\n        expect.objectContaining({\n          context: {\n            operation: 'deleteContent',\n            resource: contentPath\n          }\n        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get(':operation')).toBe('delete');\n      expect(formData.get('force')).toBe('true');\n      expect(formData.get(':applyTo')).toBe('tree');\n    });\n\n    it('should throw validation error for missing content path', async () => {\n      await expect(contentService.deleteContent('')).rejects.toThrow(AEMException);\n      await expect(contentService.deleteContent('')).rejects.toThrow('Content path is required');\n    });\n\n    it('should throw error when trying to delete system paths', async () => {\n      const systemPaths = ['/apps', '/libs', '/system', '/etc/designs', '/var/audit'];\n      \n      for (const systemPath of systemPaths) {\n        await expect(contentService.deleteContent(systemPath)).rejects.toThrow(AEMException);\n        await expect(contentService.deleteContent(systemPath)).rejects.toThrow('Cannot delete system path');\n      }\n    });\n  });\n\n  describe('reindexContent', () => {\n    const mockReindexResponse = {\n      success: true,\n      data: {\n        success: true,\n        jobId: 'reindex-job-123',\n        message: 'Reindexing initiated'\n      },\n      metadata: {\n        timestamp: new Date(),\n        requestId: 'test-request-id',\n        duration: 100\n      }\n    };\n\n    it('should reindex content successfully', async () => {\n      const contentPath = '/content/test';\n      const options: ReindexOptions = {\n        async: true,\n        reindexDefinitions: ['lucene', 'damAssetLucene']\n      };\n\n      mockClient.post.mockResolvedValue(mockReindexResponse);\n\n      const result = await contentService.reindexContent(contentPath, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.success).toBe(true);\n      expect(result.data!.path).toBe(contentPath);\n      expect(result.data!.jobId).toBe('reindex-job-123');\n      expect(result.data!.status).toBe('INITIATED');\n\n      expect(mockClient.post).toHaveBeenCalledWith(\n        '/system/console/jmx/org.apache.jackrabbit.oak%3Aname%3DLucene%20Index%2Ctype%3DLuceneIndex/op/reindex',\n        expect.any(Object), // FormData\n        expect.objectContaining({\n          context: {\n            operation: 'reindexContent',\n            resource: contentPath\n          }\n        })\n      );\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('path')).toBe(contentPath);\n      expect(formData.get('cmd')).toBe('reindex');\n      expect(formData.get('async')).toBe('true');\n      expect(formData.get('reindexDefinitions[0]')).toBe('lucene');\n      expect(formData.get('reindexDefinitions[1]')).toBe('damAssetLucene');\n    });\n\n    it('should handle synchronous reindexing', async () => {\n      const contentPath = '/content/test';\n      const options: ReindexOptions = {\n        async: false\n      };\n\n      mockClient.post.mockResolvedValue(mockReindexResponse);\n\n      const result = await contentService.reindexContent(contentPath, options);\n\n      expect(result.success).toBe(true);\n      expect(result.data!.status).toBe('COMPLETED');\n      \n      // Verify form data\n      const formData = mockClient.post.mock.calls[0][1] as FormData;\n      expect(formData.get('async')).toBe('false');\n    });\n\n    it('should throw validation error for missing content path', async () => {\n      await expect(contentService.reindexContent('')).rejects.toThrow(AEMException);\n      await expect(contentService.reindexContent('')).rejects.toThrow('Content path is required');\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle network errors gracefully', async () => {\n      const networkError = new Error('ECONNREFUSED');\n      mockClient.post.mockRejectedValue(networkError);\n\n      await expect(contentService.createFolder('/content', 'folder')).rejects.toThrow(AEMException);\n      await expect(contentService.createFolder('/content', 'folder')).rejects.toThrow('Unexpected error while creating folder');\n    });\n\n    it('should preserve original AEMException', async () => {\n      const originalError = new AEMException('Original error', 'AUTHENTICATION_ERROR', false);\n      mockClient.post.mockRejectedValue(originalError);\n\n      await expect(contentService.uploadFile('/content', 'file.txt', Buffer.from('test'))).rejects.toThrow('Original error');\n    });\n\n    it('should handle malformed responses', async () => {\n      const malformedResponse = {\n        success: false,\n        data: null\n      };\n      mockClient.post.mockResolvedValue(malformedResponse);\n\n      await expect(contentService.deleteContent('/content/test')).rejects.toThrow(AEMException);\n      await expect(contentService.deleteContent('/content/test')).rejects.toThrow('Failed to delete content');\n    });\n  });\n\n  describe('MIME type detection', () => {\n    it('should detect common MIME types correctly', async () => {\n      const testCases = [\n        { fileName: 'image.jpg', expectedMimeType: 'image/jpeg' },\n        { fileName: 'document.pdf', expectedMimeType: 'application/pdf' },\n        { fileName: 'video.mp4', expectedMimeType: 'video/mp4' },\n        { fileName: 'audio.mp3', expectedMimeType: 'audio/mpeg' },\n        { fileName: 'text.txt', expectedMimeType: 'text/plain' },\n        { fileName: 'data.json', expectedMimeType: 'application/json' },\n        { fileName: 'unknown.xyz', expectedMimeType: 'application/octet-stream' }\n      ];\n\n      mockClient.post.mockResolvedValue({\n        success: true,\n        data: { success: true },\n        metadata: { timestamp: new Date() }\n      });\n\n      for (const testCase of testCases) {\n        await contentService.uploadFile('/content', testCase.fileName, Buffer.from('test'));\n        \n        const formData = mockClient.post.mock.calls[mockClient.post.mock.calls.length - 1][1] as FormData;\n        expect(formData.get('jcr:content/jcr:mimeType')).toBe(testCase.expectedMimeType);\n      }\n    });\n  });\n});